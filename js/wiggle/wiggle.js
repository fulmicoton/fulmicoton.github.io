// Generated by CoffeeScript 1.4.0
(function() {
  var Animation, camera_from_angle, compute_animation, create_image_data, fill_with_average, load_animation, load_image_data, render_scene;

  load_image_data = function(path, callback) {
    var img;
    img = new Image();
    img.src = path;
    return img.onload = function() {
      var H, W, canvas, ctx, img_data;
      W = img.width;
      H = img.height;
      canvas = document.createElement('canvas');
      canvas.width = W;
      canvas.height = H;
      ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, W, H);
      img_data = ctx.createImageData(W, H);
      return callback(ctx.getImageData(0, 0, W, H));
    };
  };

  create_image_data = function(W, H) {
    var canvas, ctx;
    canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');
    return ctx.createImageData(W, H);
  };

  fill_with_average = function(data, W, H) {
    var N, b, c, g, neighbor, neighbor_count, neighbor_offset, r, _i, _j, _len, _ref, _ref1, _results;
    N = W * H * 4;
    _results = [];
    for (c = _i = 0; _i < N; c = _i += 4) {
      if (data[c + 3] === 0) {
        neighbor_count = 0;
        _ref = [0, 0, 0], r = _ref[0], g = _ref[1], b = _ref[2];
        _ref1 = [-W * 4, W * 4, -4, 4];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          neighbor = _ref1[_j];
          neighbor_offset = c + neighbor;
          if ((0 <= neighbor_offset && neighbor_offset < N)) {
            if (data[neighbor_offset + 3] > 0) {
              neighbor_count += 1;
              r += data[neighbor_offset + 0];
              g += data[neighbor_offset + 1];
              b += data[neighbor_offset + 2];
            }
          }
        }
        if (neighbor_count > 0) {
          data[c] = Math.ceil(r / neighbor_count);
          data[c + 1] = Math.ceil(g / neighbor_count);
          data[c + 2] = Math.ceil(b / neighbor_count);
          if (neighbor_count > 1) {
            _results.push(data[c + 3] = 255);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  render_scene = function(img, depth, camera) {
    var H, N, W, c, d, d0, depthp, dest, destc, destp, i, imgp, j, r, v, x, x0, y, y0, _i, _j, _k, _l, _ref;
    W = img.width;
    H = img.height;
    dest = create_image_data(W, H);
    imgp = img.data;
    depthp = depth.data;
    destp = dest.data;
    x0 = Math.ceil(W / 2);
    y0 = Math.ceil(H / 2);
    d0 = depthp[(x0 + W * y0) * 4];
    c = 0;
    N = W * H * 4;
    for (j = _i = 0; 0 <= H ? _i < H : _i > H; j = 0 <= H ? ++_i : --_i) {
      for (i = _j = 0; 0 <= W ? _j < W : _j > W; i = 0 <= W ? ++_j : --_j) {
        d = depthp[c] - d0;
        r = camera.L / (camera.L - d);
        x = Math.floor(x0 - camera.x + (camera.x + i - x0) * r);
        y = Math.floor(y0 - camera.y + (camera.y + j - y0) * r);
        destc = (x + W * y) * 4;
        if ((0 <= destc && destc < N)) {
          for (v = _k = 0; _k <= 3; v = ++_k) {
            destp[destc + v] = imgp[c + v];
          }
        }
        c += 4;
      }
    }
    fill_with_average(destp, W, H);
    for (c = _l = 0, _ref = W * H * 4; _l < _ref; c = _l += 4) {
      destp[c + 3] = 255;
    }
    return dest;
  };

  Animation = (function() {
    /*
        Just a small class hosting frames
    */

    function Animation(frames) {
      this.frames = frames;
      if (this.frames.length === 0) {
        throw "Your animation requires at least one frame.";
      }
    }

    Animation.prototype.play = function(canvas, speed) {
      var ctx, frame_id, render_frame,
        _this = this;
      if (speed == null) {
        speed = 12;
      }
      this.stop();
      ctx = canvas.getContext('2d');
      frame_id = 0;
      canvas.width = this.width();
      canvas.height = this.height();
      render_frame = function() {
        frame_id = (frame_id + 1) % _this.frames.length;
        return ctx.putImageData(_this.frames[frame_id], 0, 0);
      };
      return this.timer = setInterval(render_frame, 1000.0 / speed);
    };

    Animation.prototype.stop = function() {
      if (this.timer != null) {
        clearInterval(this.timer);
        return this.timer = null;
      }
    };

    Animation.prototype.height = function() {
      return this.frames[0].height;
    };

    Animation.prototype.width = function() {
      return this.frames[0].width;
    };

    return Animation;

  })();

  camera_from_angle = function(h, theta) {
    return {
      x: Math.cos(theta) * h,
      y: Math.sin(theta) * h,
      L: 2000
    };
  };

  compute_animation = function(img, depth, cameras) {
    var camera;
    return new Animation((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = cameras.length; _i < _len; _i++) {
        camera = cameras[_i];
        _results.push(render_scene(img, depth, camera));
      }
      return _results;
    })());
  };

  load_animation = function(animation_id, canvas, callback) {
    var cameras, h, i, nb_frames, theta, thetas;
    nb_frames = 12;
    h = 60.0;
    thetas = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= nb_frames ? _i < nb_frames : _i > nb_frames; i = 0 <= nb_frames ? ++_i : --_i) {
        _results.push(Math.PI * 2.0 * i / nb_frames);
      }
      return _results;
    })();
    cameras = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = thetas.length; _i < _len; _i++) {
        theta = thetas[_i];
        _results.push(camera_from_angle(h, theta));
      }
      return _results;
    })();
    return load_image_data(animation_id + '.png', function(img) {
      return load_image_data(animation_id + '_depth.png', function(depth) {
        return callback(compute_animation(img, depth, cameras));
      });
    });
  };

  this.load_animation = load_animation;

  this.compute_animation = compute_animation;

  this.Animation = Animation;

}).call(this);
